# 非破壊的な配列の逆転の測定結果

## 概要

jsのArray.prototype.sortを使うと、破壊的なソートなので使いにくい。
非破壊的なソートはどれが速度が早いかを検証する

## 結果

clonedeepは遅い。
sliceやスプレッド演算子よりclonedeepは 8 倍ぐらい時間がかかる

| No | slice | clonedeep | スプレッド演算子 | ループ回数 |
|----|--|--|--|--|
| 1  | 52.33100000023842ms | 454.0013990001753ms  | 64.5828999998048ms  | 10000 |
| 2  | 39.9089999999851ms  | 433.57230099942535ms | 39.006501000374556ms | 10000 |
| 3  | 58.88269999995828ms | 478.1839009998366ms  | 41.82629999984056ms  | 10000 |
| 4  | 51.79029999952763ms | 407.49239999987185ms | 44.867798999883235ms | 10000 |

## ソースコード

``` js
// slice
for (let i = 0; i < 1e5; i++) {
  testArr.slice().reverse()
}

// clonedeep
for (let i = 0; i < 1e5; i++) {
  cloneDeep(testArr).reverse()
}

// スプレッド演算子
for (let i = 0; i < 1e5; i++) {
  [...testArr].reverse()
}
```
